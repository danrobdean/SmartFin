========== 06 Feb ==========

Implemented proof of concept in the java-PoC submodule (sandbox/java-PoC):
	- Command-line interface
	- Takes in acquisition time and contract definition
	- Parses contract and generates contract object (made up of combinator objects)
	- Abstract combinator object, extended by concrete combinator implementations
		- horizon, combinator type, and acquire method
	- Sub-combinators override getHorizon when needed (e.g. truncate)
	- Works pretty well until you get to a combinator which requires input, e.g. or and anytime
	- Evaluation is pretty simple in this form



========== 19 Feb ==========

Started Rust investigation:
	- Went through docs
	- Completed multiple rust tutorials
	- Implemented rust proof-of-concept:
		- Similar to Java
		- Has zero, one, and, truncate combinators
		- Uses traits/structs instead of objects/inheritance
		- Works pretty similarly to java PoC
	- Rust testing done in the rust-test submodule (sandbox/rust-test)

Separated git repo into submodules under one group (so that only one submodule must be downloaded at a time)



========== 20 Feb ==========

Started rust -> ewasm investigation:
	- Parity basically does this
	- Followed tutorial at https://github.com/paritytech/pwasm-tutorial
	- Requires specific cargo.lock for version compatibility, and doesn't build on the stable rust toolchain (I think it can but manually throws an error if you try)
	- Created rust test contract (returns owner on function call)
	- Added scripts for building (npm install web3, run parity node, then add account with curl, then run node client with deploy-contract.js)
	- Almost works, up to actually deploying the contract (transaction runs out of gas always)



========== 27 Feb ==========

Finally got a basic contract deployed:
	- Cargo toml and lock probably not correct, so fixed, also added .cargo/config, and now using yarn (instead of nothing)
	- Geth compatibility mode was required to unlock account in code in the node console, so instead unlock the account via the command to start parity (this requires creating the blockchain, creating the account, and then running the blockchain with the account unlocked - fiddly)
	- Contract transaction creation was convoluted, so simplified slightly
	- BIGGEST FIX: cargo.toml was naming the file "smart-contract-test", but in order for the wasm file to work it MUST be called "smart_contract_test" with underscores. I don't know why and idk how you're supposed to know this, but you can't preview the wasm file as wat if it's broken like this, and you can't deploy to the blockchain bc it always has "not enough gas" (not a helpful error)

Set up a private blockchain with geth, but haven't tested deploying the wasm contract as ran into the same issue as above

Minor adjustments to the smart contract, not 100% sure it even works because its late and I just got it to deploy



========== 04 Mar ==========

Contract deployment fails on first attempt (per-chain) due to incorrect gas estimation. After the first failure, the chain always estimates correctly (approx). Weird.

Improved scripts:
	- Chain-cleaning, account-initialising, and node-running now all combined into run-node.sh
	- clean-node.sh kept for standalone usage
	- Node can be run with ./run-node.sh, and this will start the parity node and then initialise the "user" account. Passing --clean will clean the blockchain.

Geth compatibility mode is used again, so the account must be unlocked from the node client before deploying a contract (this was necessary to allow multiple accounts to be accessed, which will eventually be a requirement).

Fixed issue with giving a non-integer to web3.utils.toHex for the gas value, which was breaking contract deployment when the gas multiplier wasn't an integer.

Added unit test to test smart contract, and test-running script (it works really well).

Main rust contract:
	- Set up directory with required files
	- Made basic smart contract and dir structure
	- Unit test for basic smart contract
	- Implemented some combinator objects, IMPORTANT: can't have a state variable with unknown size at compile time on the smart contract, so need another way to handle contracts (maybe serialization)




