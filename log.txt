========== 06 Feb ==========

Implemented proof of concept in the java-PoC submodule (sandbox/java-PoC):
	- Command-line interface
	- Takes in acquisition time and contract definition
	- Parses contract and generates contract object (made up of combinator objects)
	- Abstract combinator object, extended by concrete combinator implementations
		- horizon, combinator type, and acquire method
	- Sub-combinators override getHorizon when needed (e.g. truncate)
	- Works pretty well until you get to a combinator which requires input, e.g. or and anytime
	- Evaluation is pretty simple in this form



========== 19 Feb ==========

Started Rust investigation:
	- Went through docs
	- Completed multiple rust tutorials
	- Implemented rust proof-of-concept:
		- Similar to Java
		- Has zero, one, and, truncate combinators
		- Uses traits/structs instead of objects/inheritance
		- Works pretty similarly to java PoC
	- Rust testing done in the rust-test submodule (sandbox/rust-test)

Separated git repo into submodules under one group (so that only one submodule must be downloaded at a time)



========== 20 Feb ==========

Started rust -> ewasm investigation:
	- Parity basically does this
	- Followed tutorial at https://github.com/paritytech/pwasm-tutorial
	- Requires specific cargo.lock for version compatibility, and doesn't build on the stable rust toolchain (I think it can but manually throws an error if you try)
	- Created rust test contract (returns owner on function call)
	- Added scripts for building (npm install web3, run parity node, then add account with curl, then run node client with deploy-contract.js)
	- Almost works, up to actually deploying the contract (transaction runs out of gas always)



========== 27 Feb ==========

Finally got a basic contract deployed:
	- Cargo toml and lock probably not correct, so fixed, also added .cargo/config, and now using yarn (instead of nothing)
	- Geth compatibility mode was required to unlock account in code in the node console, so instead unlock the account via the command to start parity (this requires creating the blockchain, creating the account, and then running the blockchain with the account unlocked - fiddly)
	- Contract transaction creation was convoluted, so simplified slightly
	- BIGGEST FIX: cargo.toml was naming the file "smart-contract-test", but in order for the wasm file to work it MUST be called "smart_contract_test" with underscores. I don't know why and idk how you're supposed to know this, but you can't preview the wasm file as wat if it's broken like this, and you can't deploy to the blockchain bc it always has "not enough gas" (not a helpful error)

Set up a private blockchain with geth, but haven't tested deploying the wasm contract as ran into the same issue as above

Minor adjustments to the smart contract, not 100% sure it even works because its late and I just got it to deploy



========== 04 Mar ==========

Contract deployment fails on first attempt (per-chain) due to incorrect gas estimation. After the first failure, the chain always estimates correctly (approx). Weird.

Improved scripts:
	- Chain-cleaning, account-initialising, and node-running now all combined into run-node.sh
	- clean-node.sh kept for standalone usage
	- Node can be run with ./run-node.sh, and this will start the parity node and then initialise the "user" account. Passing --clean will clean the blockchain.

Geth compatibility mode is used again, so the account must be unlocked from the node client before deploying a contract (this was necessary to allow multiple accounts to be accessed, which will eventually be a requirement).

Fixed issue with giving a non-integer to web3.utils.toHex for the gas value, which was breaking contract deployment when the gas multiplier wasn't an integer.

Added unit test to test smart contract, and test-running script (it works really well).

Main rust contract:
	- Set up directory with required files
	- Made basic smart contract and dir structure
	- Unit test for basic smart contract
	- Implemented some combinator objects, IMPORTANT: can't have a state variable with unknown size at compile time on the smart contract, so need another way to handle contracts (maybe serialization)



========== 08 Apr ==========

First day working after exams

Had a look at the serialization problem, and had a few possible revelations:
	- It's likely that you actually CAN fiddle with memory/heap stuff without just using read/write (using stuff like Box instead), as the other pwasm example contract (https://github.com/paritytech/pwasm-repo-contract/blob/master/contract/src/lib.rs) does it with a Vec (I think the pwaswm::std stuff implements it nicely or else they wouldn't have much purpose, i have no idea why the default example is so convoluted)

	- None of the rust code is actually running anywhere, it's compiled straight to wasm and then deployed. This means that any inputs need to be either:
		- Directly into the code (i.e. treating it as a template as discussed in the report) - doing this is a bit messy, but its by far the easiest to program for many reasons

		- Through the constructor (as an argument javascript) - this is kind of nicer from a user PoV (probably requiring less stuff to be run), and better style i guess, but is a lot harder to achieve as it requires de/reserializing whatever is received in the constructor into actual combinator objects, potentially requiring actual deserialization of numbers to strings, and then from strings to combinators
		- Cannot directly recieve strings over ABI in pwasm (despite the actual ABI docs claiming you can), so would have to serialize string in js, send in constructor, then deserialize string in rs.

Looking at js/eth abi/pwasm, it may not be so terrible to go from js -> rust with the contract definition. If it's typed into the js, it can be converted to a utf-16 array of bytes relatively painlessly, passed into the contract constructor relatively painlessly, and then reconstructed into a pwasm_std::String relatively painlessly. The problem is that this process deals with the finnicky/tempermental part of the toolchain and I'm not confident that "relatively painless" will not end up being super difficult. It's worth a try I guess, either way the rust program will have to convert string to combinator so it's not a waste (plus that logic exists in the java PoC anyway).



========== 09 Apr ==========

After some thought, it seems better imo to provide the combinator contract through the constructor. This will need to be in the form of a bytes array. Need to decide whether or not we should just send the string representing the contract serialized, or some more abstract representation (e.g. 0 = zero, 1 = one, 2 = and, 3 = or, etc..).

Sending the string serialized is less work on the javascript side, and should be easy to handle sending/receiving the data across the gap. Unfortunately, it requires doing string processing in the smart contract constructor. Not only does this cost gas, but it may be difficult due to lacking the std lib (should only really need a split function though). Also, we still need to do string processing on the js side for verification.

Sending a simpler representation of the contract in a bytes array requires manual serialization on the JS side, manual deserialization on the rs side, and coordinating these two sides to use the same serialization method (will have to code (de)serialization once per side). This is more work from a dev standpoint, but moves all string processing to the JS side, and reduces the gas cost and complexity of the smart contract. It does require sending a poorly-defined data type through the constructor which could be considered bad design, however.

Decided to use the serialize in JS to bytes, then deserialise in rs.

- Written code to deserialize vector of bytes in rust
- Smart contract populates itself with combinators (all boxed so should stay in memory)
- Constructor now accepts vector of bytes, hopefully should be able to send a byte array from JS and it should curry automatically
- Added tests for various deserialized combinators



========== 11 Apr ==========

Have tested passing a Uint8Array into the constructor in JS when deploying on the parity chain, seems to work perfectly!! Also throws exceptions when the constructor panics (due to empty array or invalid combinator sequence), which is good (panic works as expected). This is really good news as I expected it to be a massive pain.

Added combinator contract parsing to JS, through user input (using node's readline module). A contract can be passed in, and is parsed and serialized, then a contract is deployed with the serialized combinator contract passed to the constructor, then the smart contract deserializes the combinator contract into combinator objects (in rust). Works nicely!

Added a deploy.sh script which runs everything needed to deploy a contract with cli input (on the parity node).

Major features which still need implementing:
	- Date/time (truncate)
	- Observables and "or" combinator
	- Stake and withdrawal
	- Signing and setting potential holder
	- Acquisition and related combinators (anytime, get)

- Have implemented holder
- Implemented staking by holder and counter-party
- Improved module layout so all combinators are imported through one import (don't need to import new combinators in financial_sc.rs, only combinators/mod.rs)
- deploy_contract.js modified to also take holder address
- Added null combinator, instead of using Option<Box<ContractCombinator>> (so that the contract is initialised with NullCombinator, instead of None, before calling the constructor):
	Null combinator always throws errors, as it isn't meant to be used post-initialisation. It is used to replace None as they basically function the same, and although None is a bit nicer as a rust builtin, having to unwrap Some(Box(Combinator)) every time we do anything is pretty obnoxious, and the function hasn't really changed. This does add a "new" combinator, which is a bit dodgy design-wise so need to mention that somewhere! Of course, it's not actually a part of the combinator language, as it can't be used when writing contracts in the DSL.



========== 12 Apr ==========

Planning to implement SCALE and OR. This requires dealing with observables/input to the contract. Some thoughts:
	- Given lack of maps (no std), will likely store these in a vector (i.e. vec for OR choices, vec for OBS values, etc)
	- Indexing of each OR will be 0 to N for N OR combinators in a contract, same for unprovided observables
	- Observables could be pre-defined in the contract (e.g. SCALE 5 ONE will always be worth 5), or left undefined and provided later (something like SCALE OBS ONE)
	- A contract with undefined observables in the subset of combinators which will currently be acquired cannot be acquired, and probably cannot be evaluated
	- A contract with undefined observables in the subset of combinators which will not be acquired can be acquired (e.g. acquire(2) of AND TRUNCATE 1 SCALE OBS ONE ONE, where the SCALE OBS ONE sub-contract won't be acquired at time 2)
	- Can denote undefined observables by "OBS" in the combinator contract
	- Observable values/OR choices can be provided in provide(index, value) functions (one for obs, one for ors) using the indexing scheme above
	- Observable values must be signed by one party and provided by the other (so both are in agreement)
	- OR choices can only be provided by the holder (always true)

Implementing OR combinator:
	- Similar to AND, but has an or_index
	- When calling get_value, the vector of or_choices must be passed down to the combinators for niceness (don't want to call back with a reference to the contract bc its cyclical)
	- ContractCombinator imports Vec and Box, so that extern crate is only called once (for the combinators) and can be switched out (theoretically, practically this will never happen)
	- OR combinator is provided an index at construction (kept track of by the length of or_choices), or choice is set to None initially
	- when get_value is called the combinator looks up its index in or_choices

Implementing TRUNCATE combinator:
	- Single sub-combinator and horizon time
	- Requires deserializing a 4-byte unix timestamp, functions implemented to do this using maths (as transmute is not available in the limited std lib)
	- Testing function added to serialize a u32 timestamp
	- All timestamps/horizons changed to u32 type for consistency (as it will always be a 32-bit unix timestamp)

Implementing SCALE combinator and observables:
	- Single sub-combinator, obs_index, and scale_value
	- Requires carrying around an obs_values vector, like the or_choices vector (except with u64 values)
	- u64 chosen as everything will have to be converted to u64 in the end anyway, so no point carrying around U256 values
	- If scale value is provided, the combinator contract will be serialized as 5 1 <8-bit scale-value> <sub-combinator>, otherwise 5 0 <sub-combinator> if an observable should be used instead
	- With no observable defined or scale value, getting value will panic
	- Setting scale value requires signature stuff, have not done yet (should hopefully not be too hard as keccak lib is provided)


NB ABOUT EXPIRED CONTRACTS: Expired contracts can be acquired (kind of), but their value is zero. This means that the wording for truncate in the report is wrong, as it says that expired contracts cannot be acquired. I think that there is nothing stopping someone from acquiring an expired contract (just as in real life, where someone can sign a contract even if the dates of payments have passed), but the contract just has a value equal to the ZERO combinator.

For tomorrow, will allow setting of observables (using signatures). Will also implement give (easy), and start looking at acquisition (hard).



========== 13 Apr ==========

Bad news, there is no ECDSA (or any encrypt/decrypt) functionality in pwasm (weirdly). This leaves two options:
	- Trying to implement a signature scheme using only Keccak (complicated, inefficient, hard to program)
	- Don't use signatures at all, instead use a voting-like system (easier to program, but has more design decisions and is not as elegant, also may take more storage (although hash-based signatures often take a lot of storage too))

Overall, it seems more sensible to forego signatures, instead using a system like:
	- Each obs_value has a concrete value, a proposed-by-holder value, and a proposed-by-counter-party value (all Option<u64>)
	- Each party can propose a value for each obs_index at any time through a function, the contract stores the latest proposed value only per observable (if holder proposes 1 then 2, only 2 is stored and 1 is lost)
	- If the two parties' latest proposed value match, then the concrete value is set to the proposed value
	- The concrete value only updates when a new matching pair of proposals occurs. If both parties propose 1, then the holder proposes 2, the concrete value is 1. If the holder and counter-party propose 2 after agreeing on 1, the concrete value is 2.

Implementing OBS values:
	- Vec<Option<u64>> for concrete values, as well as proposed values by holder and counter-party (3 vectors in total)
	- Propose obs value function updates the relevant party's proposed value for the given index
	- If both parties agree upon a proposal, the concrete values vector is updated
	- Panics if uninvolved party proposes value

NB: Will need to provide some way to view or-choices and obs-values in future, unfortunately it's a little complicated as they're Option<u64>, so will require double serialization (option and u64). May leave that until a front-end is created.

Implementing GIVE:
	- Have to change value to i64 and update all combinators
	- Have to change scale value to i64, does accepting a negative value here make sense? It does mathematically, but from a financial contract point of view, what does it mean to pay someone negative amounts of Eth?
	- Have to change obs_value to i64 (same reason, and to be consistent with scale_value)

NB: Updated all U256 to i64/u64 since apparently those are in the abi lol



========== 15 Apr ==========

Implemented THEN:
	- Similar to AND, except value takes sub_combinator0.get_value() if it hasn't expired yet, otherwise sub_combinator1.get_value(). Pretty simple

Reorganising tests:
	- Most of the tests in financial_sc.rs are integration tests, so they shouldn't really be in the same file
	- Moving most tests from financial_sc.rs to an integration tests folder
	- Adding unit tests for financial_sc (deserialization etc)
	- Adding unit tests for each combinator's file

	- Most tests in financial_sc.rs moved to separate integration test file, financial_sc.rs moved into lib.rs (as there's not a big reason to keep it separate and that's the rust way apparently)
	- Some tests kept in lib.rs as unit tests for FinancialScContract struct
	- Unit tests added for all combinators (time consuming but makes more sense this way)
	- Unit tests which should panic will now check the error message
	- Unit tests which fail should give a reason for failure
	- Due to the differing test architecture (separate crates for integration tests), the build manifest (crate-type=["cdylib"]) doesn't work (although we don't need this for any of the functionality that's actually being tested). To work around this, the cdylib is replaced with the default "lib" when the testing script is run, and then switched back after it finished. The build script also sets cdylib just to make sure. It's a bit fiddly, but there's no other way to work around this without reverting to the old test structure (which was very bad imo, unsustainable the more I add). The generate-cargo.sh script creates the templated manifests from cargo-template.toml. 

NB: Any changes to the manifest should now be made in cargo-template.toml (although I doubt there will be any).

Other misc changes:
	- All combinators with sub-combinators have horizons derived from them

Not started on get or anytime yet, hopefully can implement over the next two days (and nothing much left after that with the smart contract.



========== 16 Apr ==========

Fixing serialization/deserialization to use pwasm_std write/read functions, so that native endianness is never an issue (idk if its ever actually an issue in ewasm but better safe than sorry):
	- Both functions now use read/write_u32/u64
	- Signed 64-bit function now converts i64 to u64, and then serializes, or vice-versa for deserialization
	- To convert u64 to i64:
		- if u64 > 2^63, then i64 will be negative
		- For an n-bit number, bit[0] * 2^0 + bit[1] * 2^1... + bit[n-2] * 2^n-2 - bit[n-1] * 2^n-1 = 2's complement, or + bit[n-1] * 2^n-1 for unsigned (ignoring endianness, bit[n-1] is most significant)
		- To convert from u64 > 2^63 to i64, must do u64 - 2^64
		- This must be done as i64 = u64 - 2^63, followed by i64 = I64 - 2^62 - 2^62, to account for size limits on the types
		- This process can be done in reverse to convert i64 -> u64, i.e. u64 = (i64 + 2^62 + 2^62) as u64 + 2^63
	- Added tests for deserialization functions
	- Made numbers more complicated where deserialization occurs to ensure tests check things properly

NB: MAY LEAD TO ISSUES LATER - the read/write functions appear to use machine's native endianness, whereas can't guarantee the JS that does the serialization will use the same endianness. Might have to define the serialization/deserialization myself, to ensure endianness matches at both sides, even if it doesn't match the native endianness.

Acquisition time!! Handling acquisition finally, decided upon the following model:
	- Every combinator has an acquisition_time: Option<u32>, and a fully_updated: bool
	- When acquire is called, acquire is called on the combinator, which calls acquire on sub combinators
	- In each acquire method, the combinator sets its acquisition_time to the given acquisition_time (if it hasn't been set already), and then calls on sub-combinators
	- Combinators can only be acquired once, and only before their horizon
	- In order to handle funds, update must be called (this should be called on the contract combinator right after calling acquire)
	- update will pass down the current time, obs_values, and or_choices, and get the amount of ether which is pending payment
	- calling update on non-acquired combinators does nothing and returns 0
	- calling it on combinators acquired in the future also does nothing
	- calling it on fully-updated combinators also does nothing
	- calling it on acquired combinators which aren't fully updated will calculate the payment pending in said combinator (and its sub-combinators where relevant), and return the final value. Once a combinator's sub-combinator(s) are marked as fully_updated, it marks itself as fully_updated, to mark that no funds are pending
	- Get will set the acquisition time of the sub-combinator to the future
	- Anytime will do the same, but there will be acquire_anytime(anytime_index) functions (like obs/or) to acquire anytime combinators before the horizon

Have implemented acquire/update for null, zero, one, give, and scale, as well as tests. Stubs have been added for other combinators, to be filled in over the next two days. The FinancialScContract acquire/update methods have not been implemented.



========== 17 Apr ==========

Implementing acquire/update for more combinators (truncate, and, or, then):
	- Truncate very similar to give/scale
	- And acquires/updates both children
	- Or checks or choice (must pass around or_choices in acquire), MAY change to handle ambiguous choice case, currently just panics
		- Be careful to update based on acquisition_time, not time
	- Then similar to or except based on horizon, not or choice
		- Again, use acquisition_time not time

Ensure that after acquiring the contract, or_choices and obs_values do not change (or have some limitation on their modification)
Acquiring the contract should fail if missing or_choices or obs_values (should this happen for all or_choices/obs_values, or only ones on the active branch of the contract? If only the active branch, can handle during acquisition in the combinators which are missing information by panicking, the panic should propagate up the contract - this would require passing the or_choices/obs_values through the acquire functions though.) Maybe a separate validate function on the combinators, to traverse the tree cheaply before acquisition (although more expensive if validates successfully, but cheaper on failure). Also makes it easier to implement.

Can't validate during acquisition, e.g. AND - if one branch succeeds then the second fails, no way to roll-back the first acquisition, thus we need to completely validate the combinator tree before starting acquisition. Added separate acquirable method to be called before acquisition, which checks if all sub-combinators on the active branch can be acquired.

PROBLEM: Should we be able to set or choices and/or observable values AFTER acquisition? I would say that it makes sense for observable values if both parties agree and or choices if a value/choice has not already been used during an update call (i.e. can change from None to Some after calling update for the first time, but not Some(x) to Some(y)). If this change is made, should separate update and acquire (i.e. dont call update right after acquire by default), and update should lock in the concrete values. Acquire/acquirable can travers both branches on ambiguous OR, and update can return 0 on ambiguous OR/SCALE and not set fully_updated.

Changed or combinator:
	- If no or choice given, acquisition affects both branches, and update does nothing
Changed scale combinator:
	- If no obs_value or scale_value given, update does nothing

Tomorrow: Implement acquirable (may not need after or choice change and scale value change, since all combinators may just be able to be acquired always?), implement top-level acquire/update, implement get and anytime.



========== 18 Apr ==========

- Acquiring should always succeed, so don't need acquirable

Updating always succeeds, may be bad? For example, a contract and one give get 1 scale 2 one (get one now, give two later) can be acquired and updated, then when updated later without filling in the or-choice the give two never gets fulfilled. May be better to ignore non-filled-in or-choices/obs-values when updating before the acquisition time of the or/scale, but when an or/scale is updated after its acquisition time it must have a concrete or-choice or obs-value, or else it panics. This way it's harder to circumvent undesirable sub-combinators while carrying out desirable sub-combinators. This may be overkill, not really sure and probably need a discussion with another person about it. However, users may circumvent any undesirable results by simply not paying in stake, although this is easier to solve through a real world legal contract than the issue of providing or-choices.

NB: QUESTIONS TO SOLVE (LATER?):
	- Should or-choices and obs-values be unchangeable once provided, unchangeable past initial acquisition time of whole combinator, or unchangeable past the time they are relevant in calculating balance (the acquisition time of the combinator they are used by)?
	- Should updating balance require all obs-values/or-choices upfront, only relevant obs-values/or-choices, or none (and skip ambiguous combinators)?

- Removed acquirable (should always be able to acquire a combinator now)
- AND now checks if sub-combinators have expired before acquiring them (otherwise will panic, and should acquire one if possible even if the other is expired)
- Added GET:
	- Acts like GIVE without negating, and sets acquisition time on sub-combinator to its horizon
	- value is 0 before sub-combinator's horizon, value of sub-combinator afterwards
	- If sub-combinator has no horizon, value is always 0 and sub-combinator won't be acquired upon acquisition, update will also skip the sub-combinator (as no known update time)
- Added ANYTIME:
	- Acquiring does NOT acquire sub-combinator, only self combinator
	- anytime_acquisition_times vector now carried around
	- If updating and the sub-combinator isnt acquired, when an acquisition time before its horizon and after the anytime combinator's acquisition time is provided it is passed into sub.acquire
	- If no time is provided but the horizon is here/passed, sub.acquire(sub.horizon) is called
	- If neither of these two occur, update does nothing
	- Once the combinator has been acquired, it is updated as any other sub-combinator would be

To do next:
	- Add deserialization for GET and ANYTIME (8/9)
	- Add API functionality to set anytime acquisition times
	- Figure out how restrictive the contract will be on setting or-choices/obs-values/anytime-acquisition-times more than once each
	- Add top-level acquire and update to API (should be simple) and missing balance-related functions (withdraw, rename get_stake to get_balance and make signed)
	- Add integration tests for entire contracts
	- Test IRL on parity blockchain, and write integration tests for entire chain (build and deploying contract, calling functions on deployed contract from js, etc)
	- Write the web interface/evaluation tool



========== 24 Apr ==========

Adding deserialization for GET and ANYTIME, API functionality for acquire_anytime, acquire, update, and withdraw, and testing.

- Updated get_stake:
	- Renamed to get_balance
	- Balance now treated as i64, updated all returns and functions using
	- Now cannot stake more than 2^62 (as this would overflow an i64)
	- safe_add now checks underflow (as using i64s not U256)
	- Added tests for new changes

- Updated deserialization
	- Added deserialization of GET and ANYTIME (8/9)
	- Serialized contract now represented as Vec<i64>!
		- Timestamps and scale values can now be passed in/read directly, without serializing or deserializing them individually
		- Tests updated and (de/)serialization functions removed

- Added acquire and update to API
	- Relatively straightforward, some checks, update will adjust the balances accordingly

- Added acquire_anytime_sub_contract to API:
	- If the new acquisition time (current block-time) is earlier to the existing acquisition time (None is latest), then replace - this prevents setting it to after a horizon, and implicitly prevents setting it twice (sensible imo)
	- acquire on anytime now sets the acquisition time in the vector to the sub-combinator's horizon
	- acquire and update on all combinators now take anytime_acquisition_times as an &mut vec
	- update on anytime now only acquires the sub-combinator when the acquisition time has passed (simpler), and panics if the self-acquisition-time is later than sub-acquisition-time (should never get there anyway), also uses sub-horizon if the given acquisition time is later (this should never happen but done just in case)
	- All tests adjusted

- Added withdraw function to API:
	- Takes an amount to withdraw
	- Amount is clamped by the user's balance
	- If the user can't afford to pay 2300 Wei in gas for the transfer, no transfer occurs
	- If the user isn't involved in the contract, no transfer occurs
	- The contract transfers using the call function

- Testing
	- Added unit tests for acquire, update, anytime acquire, withdraw
	- Testing withdraw's call functionality doesn't seem possible using pwasm_test, can only test calls to known contract methods, not the call function

Need to add more integration tests, then javascript tests (deploy -> integration tests), then javascript client.



========== 25 Apr ==========

Adding more integration tests, then setting up javascript testing. Also remove TODOs (get_value)

Misc changes:
	- GET combinator now sets fully_updated when the sub-combinator has no horizon (i.e. can never be acquired, so update will never give any result, hence fully updated)
	- GET and ANYTIME when updated at horizon will count sub-combinator as already acquired, even before expiration (follows the paper more closely, acquisition is at last non-expired moment, not first expired moment)
	- Replaced all assert_eq!(bool, x) with assert!(x)/assert!(!x) bc it's better
	- Added get_concluded to contract API, used to check if the contract is done updating forever (checks if fully_updated or expired) - could be used for suicide in future

Integration tests:
	- GET and ANYTIME, using get_balance instead of get_value (better from integration test standpoint)
	- get_concluded tests
	- Extra should_panic tests for concluded contract, acquisition post-expiry

JavaScript testing plan:
	- Create scripts to initialise and run clean parity blockchainf
	- Rust smart contract should be built and then deployed to the blockchain
	- Javascript tests should initialize, setting up web3 with hard coded test accounts
	- Unit tests should check that interfacing with contract works correctly (i.e. the API), no need to test all combinators as they're already tested, just interaction between js client and endpoint

Testing implementation:
	- Realised contract deployment was broken since the test migration, caused by the deletion of .cargo/config (done in attempt to make building work without the cdylib/lib issues), added the config back and converted the Uint8Array to a normal array and now works properly
	- Reorganised repo, rust contract stuff moved to contract folder, js testing in new contract-js-test folder
	- Added mocha for testing, and babel for ES6 imports
	- contract-utils.mjs now holds contract management functions, deploy-contract.mjs now just calls into them, as will test.js
	- Mocha tests first deploy contract (attempted twice in case of first push), then run tests
	- Started with get_holder and get_counter_party, but weird results. get_holder is just returning Address::zero, even though the holder is not just zero in the constructor (have checked). For the counter_party it's the same, but the sender IS Address::zero in the constructor, which it shouldn't be.



========== 27 Apr ==========

Bad news, I misinterpreted the repo contract, which has a storage table stored in the struct of the contract instance. I assumed this implied that stuff stored on the struct (in rust's heap) stays around forever, but this is not the case. The storage table is simply updated while the contract is executing, and then emptied once the contract is exited. Anything not in the table at any given time will be in the contract's storage (pwasm_ethereum::write/read). This means I need to be able to serialize (and store in eth storage):
	- All numbers associated with the contract (balance, addresses) - not a big deal
	- Options (a bit fiddly but doable)
	- The vectors representing OR choices (length then items, not tooo hard)
	- The combinator structs (a massive pain)

This also (annoyingly) means that there will be two separate serializations of the combinator contracts, one for the definition and one for the existing structs. I kind of hate this but I don't think there's any other way, the JS serialization shouldn't have knowledge of the RS minutiae. At least it should be easy to test

Sadly, I think this will all take 3 days to a week, putting me about two weeks behind my intended deadline for the smart contract. At least I don't think the second part will take too long (front end client basically), should be doable within two weeks so shouldn't run out of time for the report.

Will aim to have storage existing along with addresses/numbers stored by end of today, options/vectors and starting on combinators tomorrow, combinators by end of mon.

NB: The contract struct is reinitialized every time a method is called, in the call/deploy functions. This is why everything is reset to 0 every time.

Implementing storage:
	- Implemented storage struct/methods, used same struct from the example repo contract
	- Re-implementing i64 to/from [u8] (via u64), from old code, also implemented address to/from [u8]
	- Have replaced holder, counter_party, holder_balance, counter_party_balance, and serialized_combinator fields with stored values, now passes js tests! So storage is working on the blockchain.
	- Storage struct now uses Stores<T> trait, which can write/read a type T
	- Implemented Stores for [u8; 32], i64, Address, and Vec<T> where Stores<T> (had to make a read_len and write_len so that vec lengths can always be read/written)

To do still:
	- Need to implement storage of bools, Option<T> and the combinator structs (will require serialization methods on the combinator structs themselves)
	- Unit tests still pass (should add new ones though, specifically for key addition)

REALISED A PROBLEM/SOLUTION:
	- Vec<T> can be stored only if storage of T only uses one slot, e.g. Vec<Vec<T>> will break
	- Same may be an issue with Option if we use 2 slots for that, Vec<Option<T>> will break
	- Change write to return a key, representing the end of the array used, i.e. write(key, vec![1, 2, 3]) == key + 3, next write should be at key + 3 + 1



========== 28 Apr ==========

Implementing the fix for writing multiple slots in storage, then implementing bool and Option<T>, then starting on combinators.

Another issue has reared its head. Having implemented returning end-addresses for read/writes, it's become obvious that these could change, for example if writing a vector and then re-writing it with an additional element the end address will be 1 element further into storage. If this is possible, then dynamically deciding addresses based on other addresses should never be done. There are a few options to fix this:
	- Namespacing memory - we can use the last byte of the address as a "namespace" byte. Any dynamically-sized vectors can have their own memory namespace, and the add_to_key function can iterate only over the first 31 bytes of the addresses (so that namespace boundaries are never crossed). This is obviously quite restrictive, but it doesn't matter at all in the context of the specific smart contract.
	- Matching IDs to memory, and dynamically organising it. This is the best design-wise, but it's a ton of work and not very efficient either. Involves keeping track of when memory for an item will overlap memory for another item, and moving the second item to fresh memory. This is a giant pain, and I almost definitely won't implement it, but it is basically the ideal solution.
	- Enforcing type/size immutability on stored vectors. This means that if a vector has been written to storage, it cannot be re-written unless the new vector has the same size in memory (i.e. length and size of items are equal). This will prevent overlapping a vector with a vector stored after it, as it will never grow in storage. This requires adding checks and keeping track of the size/length of stored arrays, which could get difficult/inefficient with types like Vec<Vec<Option<Vec<T>>>> (not that we use anything more complicated than Vec<Option<T>>).

Will probably go with the idea of namespacing memory for now, as it is very easy to implement and replace later.

Stuff done:
	- Namespacing memory (last byte is a namespace index)
	- Reads/writes return the last read/written address (used in sequential read/writes, generally ignored outside of the Storage methods)
	- Stores<Vec<T>> now actually works
	- Implemented Stores<Option<T>> and Stores<bool>
	- or_choices, obs_values, anytime_times now all stored in storage instead of members
	- Added tests for storage of different types
	- Using ext_reset in tests wipes out pwasm_ethereum::write/read storage (which is handily mocked as expected for testing usually), replaced all ext_reset calls with ext_update (which we should've been using anyway)


Combinator serialization: Probably going to be recursive, each combinator serializes its sub-combinators and then itself, and returns the overall result. Serialization will look similar to existing serialization, except with extra data on each combinator (fully_acquired, acquisition_time).  Do we need to store indeces (or_index, obs_index, anytime_index)? In theory they can just be calculated during reconstruction (as deserialize_combinator works now), so no?

Gripes:
	- Effectively two deserialization functions for the same thing, kinda ugly

Serialization/deserialization stuff done:
	- Implemented enum for combinators (finally)
	- Implemented serialization

Still needed:
	- Finish deserialization/storage of combinator structs, and (de)serialization testing
	- More JS tests
	- Methods for sending or choices, obs values, and anytime acquisition times (not straightforward as they're stored as options)
	- Remove null combinator
	- Think about using keys instead of passing around vectors through combinator functions



========== 29 Apr ==========

Finishing off deserialization of combinator structs, adding tests, removing null combinator.

Changed Stores to StoresRef and Stores:
	- StoresRef is like stores, but for passing by reference to write - prevents having to clone everything (vectors and arrays) a bunch, as we shouldn't be modifying anything passed in either way
	- StoresRef<Vec<T>> will now only store vecs where Stores<T>, not StoresRef<T> (which is fine for us and makes everything easier and imo nicer)
	- Stores<Option<T>> is used instead of StoresRef as it should be impossible to modify the option if it's immutable, but either way it doesn't matter if the option has to be cloned as the cost is practically 0 (unlike vectors or arrays) - also makes it easier to store Vec<Option<T>>, which we use extensively

Implemented deserialization:
	- As serialization is done on each combinator (necessary for encapsulation), deserialization should also be done on each combinator (also necessary for encapsulation)
	- We want to initialise the combinators from a serialized vector, not initialise and then replace values, so this needs to be called before the combinator is instantiated - and thus it can't be a trait method, which requires a receiver (due to rust internal stuff)
	- Instead, each combinator has their own deserialize method
	- ContractCombinator has higher level deserialize, used when the type of combinator isn't known (e.g. at the first call, or sub-combinators)

Testing:
	- Serialization is tested by checking the serialized list matches the details, stored variables, and serialized sub-combinators directly
	- Deserialization is tested by assuming serialization works (if it doesn't its tests will fail), so combinator.serialize() == deserialize(combinator.serialize()).serialize() is the assertion
	- Tests for all combinators written

Null combinator removed as no longer used (no combinator is stored before initialization, deserialization will just fail)


Serialization and deserialization all seem to work, and all tests pass! Now need to add JS tests.

JS tests:
	- Changed from calling done() to returning promises, as calling done() was causing issues in nested transaction callbacks
	- Added stake tests (which work)
	- Added withdraw tests (which work)

Seems that the ABI generation of pwasm doesn't set the payable attribute on the JSON ABI properly. If the attribute `"payable": true` is added to the json for the payable function (stake), then it works as expected. This is clearly a bug with pwasm, as when the payable attribute was added there were no changes made to the json generation (https://github.com/paritytech/pwasm-abi/commit/e14c00d8d0e096d4609ec9c0c2b5b9c4358dd02d). For now we'll work around it by adding the payable function manually when we test, although this requires disabling the ./build.sh line in test.sh.

The two payment functions (stake and withdraw) work, so assuming the execution of the smart contract runs on the blockchain as expected (not necessarily a given but looking promising), the smart contract should be working fully on real blockchains!



========== 30 Apr ==========

After raising an issue on the GitHub for pwasm-abi, they fixed the issue with payable not being marked in the JSON (turns out my diagnosis was exactly correct). That was a quick fix, wowee. After changing the version of pwasm-abi to 2.2 and pwasm-abi-derive to 2.3 (and updating the Cargo.lock, which we can't change/auto-generate for weird reasons), it works perfectly.

Tests:
	- Implemented serialization for rest of combinators in JS (mostly direct, truncate and scale require the extra argument to be serialized but that's all)
	- Added JS tests for API functions:
		- get_concluded
		- acquire
		- update
		- set_or_choice
		- truncate (time passed into constructor correctly)
		- scale (passing scale value and propose_obs_index)
		- anytime (acquire_anytime_sub_contract)
		- get_contract_definition

Changes made to acquire_anytime_sub_contract:
	- Previously no check that the anytime sub-contract is being acquired after the anytime contract until the contract is updated
	- This throws an error when the contract is updated after being used incorrectly, but still allows the incorrect usage in the first place
	- Need some way to throw when the anytime sub-combinator is acquired before the anytime is acquired
	- Should keep track of whether the anytime is acquired in the anytime_acquisition_times, may use a tuple of (bool, Option<u32>) where (true, x) means that anytime has been acquired
	- Requires storing (T, U) tuples, and updating anytime

	- Stores<(T, U)> where Storage: Stores<T> + Stores<U> implemented
	- anytime_acquisition_times changed from Vec<Option<u32>> to Vec<(bool, Option<u32>)> everywhere
	- Tests/code updated
	- acquire_anytime_sub_contract tests for anytime_acquisition_times[index].0, if false then panics
	- ANYTIME combinator sets anytime_acquisition_times[self.anytime_index].0 to true when acquired, thus allowing acquire_anytime_sub_contract(index) to be called
	- Test added for acquiring sub contract before acquiring parent (should panic)

NB: acquire and acquire_anytime_sub_contract will now update the contract after acquiring. This makes a lot more sense (as we were basically calling update after every acquire, and acquire_anytime_sub_contract can't be called twice without updating in between), so that non-time-based contracts are concluded immediately after acquisition. Now only time-based contracts need updating.



