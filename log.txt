========== 06 Feb ==========

Implemented proof of concept in the java-PoC submodule (sandbox/java-PoC):
	- Command-line interface
	- Takes in acquisition time and contract definition
	- Parses contract and generates contract object (made up of combinator objects)
	- Abstract combinator object, extended by concrete combinator implementations
		- horizon, combinator type, and acquire method
	- Sub-combinators override getHorizon when needed (e.g. truncate)
	- Works pretty well until you get to a combinator which requires input, e.g. or and anytime
	- Evaluation is pretty simple in this form



========== 19 Feb ==========

Started Rust investigation:
	- Went through docs
	- Completed multiple rust tutorials
	- Implemented rust proof-of-concept:
		- Similar to Java
		- Has zero, one, and, truncate combinators
		- Uses traits/structs instead of objects/inheritance
		- Works pretty similarly to java PoC
	- Rust testing done in the rust-test submodule (sandbox/rust-test)

Separated git repo into submodules under one group (so that only one submodule must be downloaded at a time)



========== 20 Feb ==========

Started rust -> ewasm investigation:
	- Parity basically does this
	- Followed tutorial at https://github.com/paritytech/pwasm-tutorial
	- Requires specific cargo.lock for version compatibility, and doesn't build on the stable rust toolchain (I think it can but manually throws an error if you try)
	- Created rust test contract (returns owner on function call)
	- Added scripts for building (npm install web3, run parity node, then add account with curl, then run node client with deploy-contract.js)
	- Almost works, up to actually deploying the contract (transaction runs out of gas always)



========== 27 Feb ==========

Finally got a basic contract deployed:
	- Cargo toml and lock probably not correct, so fixed, also added .cargo/config, and now using yarn (instead of nothing)
	- Geth compatibility mode was required to unlock account in code in the node console, so instead unlock the account via the command to start parity (this requires creating the blockchain, creating the account, and then running the blockchain with the account unlocked - fiddly)
	- Contract transaction creation was convoluted, so simplified slightly
	- BIGGEST FIX: cargo.toml was naming the file "smart-contract-test", but in order for the wasm file to work it MUST be called "smart_contract_test" with underscores. I don't know why and idk how you're supposed to know this, but you can't preview the wasm file as wat if it's broken like this, and you can't deploy to the blockchain bc it always has "not enough gas" (not a helpful error)

Set up a private blockchain with geth, but haven't tested deploying the wasm contract as ran into the same issue as above

Minor adjustments to the smart contract, not 100% sure it even works because its late and I just got it to deploy



========== 04 Mar ==========

Contract deployment fails on first attempt (per-chain) due to incorrect gas estimation. After the first failure, the chain always estimates correctly (approx). Weird.

Improved scripts:
	- Chain-cleaning, account-initialising, and node-running now all combined into run-node.sh
	- clean-node.sh kept for standalone usage
	- Node can be run with ./run-node.sh, and this will start the parity node and then initialise the "user" account. Passing --clean will clean the blockchain.

Geth compatibility mode is used again, so the account must be unlocked from the node client before deploying a contract (this was necessary to allow multiple accounts to be accessed, which will eventually be a requirement).

Fixed issue with giving a non-integer to web3.utils.toHex for the gas value, which was breaking contract deployment when the gas multiplier wasn't an integer.

Added unit test to test smart contract, and test-running script (it works really well).

Main rust contract:
	- Set up directory with required files
	- Made basic smart contract and dir structure
	- Unit test for basic smart contract
	- Implemented some combinator objects, IMPORTANT: can't have a state variable with unknown size at compile time on the smart contract, so need another way to handle contracts (maybe serialization)



========== 08 Apr ==========

First day working after exams

Had a look at the serialization problem, and had a few possible revelations:
	- It's likely that you actually CAN fiddle with memory/heap stuff without just using read/write (using stuff like Box instead), as the other pwasm example contract (https://github.com/paritytech/pwasm-repo-contract/blob/master/contract/src/lib.rs) does it with a Vec (I think the pwaswm::std stuff implements it nicely or else they wouldn't have much purpose, i have no idea why the default example is so convoluted)

	- None of the rust code is actually running anywhere, it's compiled straight to wasm and then deployed. This means that any inputs need to be either:
		- Directly into the code (i.e. treating it as a template as discussed in the report) - doing this is a bit messy, but its by far the easiest to program for many reasons

		- Through the constructor (as an argument javascript) - this is kind of nicer from a user PoV (probably requiring less stuff to be run), and better style i guess, but is a lot harder to achieve as it requires de/reserializing whatever is received in the constructor into actual combinator objects, potentially requiring actual deserialization of numbers to strings, and then from strings to combinators
		- Cannot directly recieve strings over ABI in pwasm (despite the actual ABI docs claiming you can), so would have to serialize string in js, send in constructor, then deserialize string in rs.

Looking at js/eth abi/pwasm, it may not be so terrible to go from js -> rust with the contract definition. If it's typed into the js, it can be converted to a utf-16 array of bytes relatively painlessly, passed into the contract constructor relatively painlessly, and then reconstructed into a pwasm_std::String relatively painlessly. The problem is that this process deals with the finnicky/tempermental part of the toolchain and I'm not confident that "relatively painless" will not end up being super difficult. It's worth a try I guess, either way the rust program will have to convert string to combinator so it's not a waste (plus that logic exists in the java PoC anyway).



========== 09 Apr ==========

After some thought, it seems better imo to provide the combinator contract through the constructor. This will need to be in the form of a bytes array. Need to decide whether or not we should just send the string representing the contract serialized, or some more abstract representation (e.g. 0 = zero, 1 = one, 2 = and, 3 = or, etc..).

Sending the string serialized is less work on the javascript side, and should be easy to handle sending/receiving the data across the gap. Unfortunately, it requires doing string processing in the smart contract constructor. Not only does this cost gas, but it may be difficult due to lacking the std lib (should only really need a split function though). Also, we still need to do string processing on the js side for verification.

Sending a simpler representation of the contract in a bytes array requires manual serialization on the JS side, manual deserialization on the rs side, and coordinating these two sides to use the same serialization method (will have to code (de)serialization once per side). This is more work from a dev standpoint, but moves all string processing to the JS side, and reduces the gas cost and complexity of the smart contract. It does require sending a poorly-defined data type through the constructor which could be considered bad design, however.

Decided to use the serialize in JS to bytes, then deserialise in rs.

- Written code to deserialize vector of bytes in rust
- Smart contract populates itself with combinators (all boxed so should stay in memory)
- Constructor now accepts vector of bytes, hopefully should be able to send a byte array from JS and it should curry automatically
- Added tests for various deserialized combinators



========== 11 Apr ==========

Have tested passing a Uint8Array into the constructor in JS when deploying on the parity chain, seems to work perfectly!! Also throws exceptions when the constructor panics (due to empty array or invalid combinator sequence), which is good (panic works as expected). This is really good news as I expected it to be a massive pain.

Added combinator contract parsing to JS, through user input (using node's readline module). A contract can be passed in, and is parsed and serialized, then a contract is deployed with the serialized combinator contract passed to the constructor, then the smart contract deserializes the combinator contract into combinator objects (in rust). Works nicely!

Added a deploy.sh script which runs everything needed to deploy a contract with cli input (on the parity node).

Major features which still need implementing:
	- Date/time (truncate)
	- Observables and "or" combinator
	- Stake and withdrawal
	- Signing and setting potential holder
	- Acquisition and related combinators (anytime, get)

- Have implemented holder
- Implemented staking by holder and counter-party
- Improved module layout so all combinators are imported through one import (don't need to import new combinators in financial_sc.rs, only combinators/mod.rs)
- deploy_contract.js modified to also take holder address
- Added null combinator, instead of using Option<Box<ContractCombinator>> (so that the contract is initialised with NullCombinator, instead of None, before calling the constructor):
	Null combinator always throws errors, as it isn't meant to be used post-initialisation. It is used to replace None as they basically function the same, and although None is a bit nicer as a rust builtin, having to unwrap Some(Box(Combinator)) every time we do anything is pretty obnoxious, and the function hasn't really changed. This does add a "new" combinator, which is a bit dodgy design-wise so need to mention that somewhere! Of course, it's not actually a part of the combinator language, as it can't be used when writing contracts in the DSL.



========== 12 Apr ==========

Planning to implement SCALE and OR. This requires dealing with observables/input to the contract. Some thoughts:
	- Given lack of maps (no std), will likely store these in a vector (i.e. vec for OR choices, vec for OBS values, etc)
	- Indexing of each OR will be 0 to N for N OR combinators in a contract, same for unprovided observables
	- Observables could be pre-defined in the contract (e.g. SCALE 5 ONE will always be worth 5), or left undefined and provided later (something like SCALE OBS ONE)
	- A contract with undefined observables in the subset of combinators which will currently be acquired cannot be acquired, and probably cannot be evaluated
	- A contract with undefined observables in the subset of combinators which will not be acquired can be acquired (e.g. acquire(2) of AND TRUNCATE 1 SCALE OBS ONE ONE, where the SCALE OBS ONE sub-contract won't be acquired at time 2)
	- Can denote undefined observables by "OBS" in the combinator contract
	- Observable values/OR choices can be provided in provide(index, value) functions (one for obs, one for ors) using the indexing scheme above
	- Observable values must be signed by one party and provided by the other (so both are in agreement)
	- OR choices can only be provided by the holder (always true)

Implementing OR combinator:
	- Similar to AND, but has an or_index
	- When calling get_value, the vector of or_choices must be passed down to the combinators for niceness (don't want to call back with a reference to the contract bc its cyclical)
	- ContractCombinator imports Vec and Box, so that extern crate is only called once (for the combinators) and can be switched out (theoretically, practically this will never happen)
	- OR combinator is provided an index at construction (kept track of by the length of or_choices), or choice is set to None initially
	- when get_value is called the combinator looks up its index in or_choices

Implementing TRUNCATE combinator:
	- Single sub-combinator and horizon time
	- Requires deserializing a 4-byte unix timestamp, functions implemented to do this using maths (as transmute is not available in the limited std lib)
	- Testing function added to serialize a u32 timestamp
	- All timestamps/horizons changed to u32 type for consistency (as it will always be a 32-bit unix timestamp)

Implementing SCALE combinator and observables:
	- Single sub-combinator, obs_index, and scale_value
	- Requires carrying around an obs_values vector, like the or_choices vector (except with u64 values)
	- u64 chosen as everything will have to be converted to u64 in the end anyway, so no point carrying around U256 values
	- If scale value is provided, the combinator contract will be serialized as 5 1 <8-bit scale-value> <sub-combinator>, otherwise 5 0 <sub-combinator> if an observable should be used instead
	- With no observable defined or scale value, getting value will panic
	- Setting scale value requires signature stuff, have not done yet (should hopefully not be too hard as keccak lib is provided)


NB ABOUT EXPIRED CONTRACTS: Expired contracts can be acquired (kind of), but their value is zero. This means that the wording for truncate in the report is wrong, as it says that expired contracts cannot be acquired. I think that there is nothing stopping someone from acquiring an expired contract (just as in real life, where someone can sign a contract even if the dates of payments have passed), but the contract just has a value equal to the ZERO combinator.

For tomorrow, will allow setting of observables (using signatures). Will also implement give (easy), and start looking at acquisition (hard).



========== 13 Apr ==========

Bad news, there is no ECDSA (or any encrypt/decrypt) functionality in pwasm (weirdly). This leaves two options:
	- Trying to implement a signature scheme using only Keccak (complicated, inefficient, hard to program)
	- Don't use signatures at all, instead use a voting-like system (easier to program, but has more design decisions and is not as elegant, also may take more storage (although hash-based signatures often take a lot of storage too))

Overall, it seems more sensible to forego signatures, instead using a system like:
	- Each obs_value has a concrete value, a proposed-by-holder value, and a proposed-by-counter-party value (all Option<u64>)
	- Each party can propose a value for each obs_index at any time through a function, the contract stores the latest proposed value only per observable (if holder proposes 1 then 2, only 2 is stored and 1 is lost)
	- If the two parties' latest proposed value match, then the concrete value is set to the proposed value
	- The concrete value only updates when a new matching pair of proposals occurs. If both parties propose 1, then the holder proposes 2, the concrete value is 1. If the holder and counter-party propose 2 after agreeing on 1, the concrete value is 2.

Implementing OBS values:
	- Vec<Option<u64>> for concrete values, as well as proposed values by holder and counter-party (3 vectors in total)
	- Propose obs value function updates the relevant party's proposed value for the given index
	- If both parties agree upon a proposal, the concrete values vector is updated
	- Panics if uninvolved party proposes value

NB: Will need to provide some way to view or-choices and obs-values in future, unfortunately it's a little complicated as they're Option<u64>, so will require double serialization (option and u64). May leave that until a front-end is created.

Implementing GIVE:
	- Have to change value to i64 and update all combinators
	- Have to change scale value to i64, does accepting a negative value here make sense? It does mathematically, but from a financial contract point of view, what does it mean to pay someone negative amounts of Eth?
	- Have to change obs_value to i64 (same reason, and to be consistent with scale_value)


