========== 06 Feb ==========

Implemented proof of concept in the java-PoC submodule (sandbox/java-PoC):
	- Command-line interface
	- Takes in acquisition time and contract definition
	- Parses contract and generates contract object (made up of combinator objects)
	- Abstract combinator object, extended by concrete combinator implementations
		- horizon, combinator type, and acquire method
	- Sub-combinators override getHorizon when needed (e.g. truncate)
	- Works pretty well until you get to a combinator which requires input, e.g. or and anytime
	- Evaluation is pretty simple in this form



========== 19 Feb ==========

Started Rust investigation:
	- Went through docs
	- Completed multiple rust tutorials
	- Implemented rust proof-of-concept:
		- Similar to Java
		- Has zero, one, and, truncate combinators
		- Uses traits/structs instead of objects/inheritance
		- Works pretty similarly to java PoC
	- Rust testing done in the rust-test submodule (sandbox/rust-test)

Separated git repo into submodules under one group (so that only one submodule must be downloaded at a time)



========== 20 Feb ==========

Started rust -> ewasm investigation:
	- Parity basically does this
	- Followed tutorial at https://github.com/paritytech/pwasm-tutorial
	- Requires specific cargo.lock for version compatibility, and doesn't build on the stable rust toolchain (I think it can but manually throws an error if you try)
	- Created rust test contract (returns owner on function call)
	- Added scripts for building (npm install web3, run parity node, then add account with curl, then run node client with deploy-contract.js)
	- Almost works, up to actually deploying the contract (transaction runs out of gas always)



========== 27 Feb ==========

Finally got a basic contract deployed:
	- Cargo toml and lock probably not correct, so fixed, also added .cargo/config, and now using yarn (instead of nothing)
	- Geth compatibility mode was required to unlock account in code in the node console, so instead unlock the account via the command to start parity (this requires creating the blockchain, creating the account, and then running the blockchain with the account unlocked - fiddly)
	- Contract transaction creation was convoluted, so simplified slightly
	- BIGGEST FIX: cargo.toml was naming the file "smart-contract-test", but in order for the wasm file to work it MUST be called "smart_contract_test" with underscores. I don't know why and idk how you're supposed to know this, but you can't preview the wasm file as wat if it's broken like this, and you can't deploy to the blockchain bc it always has "not enough gas" (not a helpful error)

Set up a private blockchain with geth, but haven't tested deploying the wasm contract as ran into the same issue as above

Minor adjustments to the smart contract, not 100% sure it even works because its late and I just got it to deploy



========== 04 Mar ==========

Contract deployment fails on first attempt (per-chain) due to incorrect gas estimation. After the first failure, the chain always estimates correctly (approx). Weird.

Improved scripts:
	- Chain-cleaning, account-initialising, and node-running now all combined into run-node.sh
	- clean-node.sh kept for standalone usage
	- Node can be run with ./run-node.sh, and this will start the parity node and then initialise the "user" account. Passing --clean will clean the blockchain.

Geth compatibility mode is used again, so the account must be unlocked from the node client before deploying a contract (this was necessary to allow multiple accounts to be accessed, which will eventually be a requirement).

Fixed issue with giving a non-integer to web3.utils.toHex for the gas value, which was breaking contract deployment when the gas multiplier wasn't an integer.

Added unit test to test smart contract, and test-running script (it works really well).

Main rust contract:
	- Set up directory with required files
	- Made basic smart contract and dir structure
	- Unit test for basic smart contract
	- Implemented some combinator objects, IMPORTANT: can't have a state variable with unknown size at compile time on the smart contract, so need another way to handle contracts (maybe serialization)



========== 08 Apr ==========

First day working after exams

Had a look at the serialization problem, and had a few possible revelations:
	- It's likely that you actually CAN fiddle with memory/heap stuff without just using read/write (using stuff like Box instead), as the other pwasm example contract (https://github.com/paritytech/pwasm-repo-contract/blob/master/contract/src/lib.rs) does it with a Vec (I think the pwaswm::std stuff implements it nicely or else they wouldn't have much purpose, i have no idea why the default example is so convoluted)

	- None of the rust code is actually running anywhere, it's compiled straight to wasm and then deployed. This means that any inputs need to be either:
		- Directly into the code (i.e. treating it as a template as discussed in the report) - doing this is a bit messy, but its by far the easiest to program for many reasons

		- Through the constructor (as an argument javascript) - this is kind of nicer from a user PoV (probably requiring less stuff to be run), and better style i guess, but is a lot harder to achieve as it requires de/reserializing whatever is received in the constructor into actual combinator objects, potentially requiring actual deserialization of numbers to strings, and then from strings to combinators
		- Cannot directly recieve strings over ABI in pwasm (despite the actual ABI docs claiming you can), so would have to serialize string in js, send in constructor, then deserialize string in rs.

Looking at js/eth abi/pwasm, it may not be so terrible to go from js -> rust with the contract definition. If it's typed into the js, it can be converted to a utf-16 array of bytes relatively painlessly, passed into the contract constructor relatively painlessly, and then reconstructed into a pwasm_std::String relatively painlessly. The problem is that this process deals with the finnicky/tempermental part of the toolchain and I'm not confident that "relatively painless" will not end up being super difficult. It's worth a try I guess, either way the rust program will have to convert string to combinator so it's not a waste (plus that logic exists in the java PoC anyway).



