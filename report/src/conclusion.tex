\chapter{Conclusions}

In this work we have presented a system for defining financial contracts in the domain-specific language SmartFin, evaluating them, deploying their corresponding smart contract representations to the blockchain, and interacting with these deployed financial smart contracts. The smart contract representations of SmartFin financial smart contracts is sufficiently accurate with few compromises, and all major functionality is thoroughly tested to ensure correctness. \\

The implementation of these tools show that many financial contracts \textit{can} be represented with sufficient accuracy by a smart contract implementation, despite discrepancies caused by the nature of smart contracts, and that this does not necessarily require significant work by the financial contract author. The generic smart contract implementation of SmartFin can instead allow financial smart contract authors to focus only on the implementation of the SmartFin financial contract, and to ignore the smart contract implementation. This method of development can be significantly easier on the financial smart contract author. Robustness of these financial smart contracts is also improved, as the generic smart contract implementation can be thoroughly tested with no extra effort, meaning that individual financial smart contracts do not need to undergo testing as long as the SmartFin contract definition is fully tested. \\

SmartFin financial contracts can also be evaluated relatively easily, compared to traditional financial smart contracts, thanks to the simple syntax of the DSL. This enables financial contracts to be evaluated before publishing, thus allowing financial contract authors to check their contracts for erroneous behaviour. Any implementation of an evaluation algorithm for SmartFin will apply to any SmartFin financial contract, greatly reducing the work required to evaluate \textit{any} specific contract; traditional financial contracts and bespoke financial smart contracts would instead need to be evaluated individually, through complex logical and mathematical analysis that is difficult to automate. \\

The SmartFin DSL's functional and combinatorial nature can be represented quite elegantly using a simple tree of trait objects; this maintains the compositional and encapsulated nature of each combinator, while still keeping track of all state required during program execution. \\

While SmartFin may not fit the needs of every financial institution, the findings presented can be generalised to apply to any similar combinatorial financial contract DSL. Implementing a generic smart contract that can represent any financial contract written in a specific DSL has all of the benefits stated here for SmartFin, including ease of implementation, improved robustness, and ease of evaluation. While bespoke smart contracts may be more efficient in terms of gas costs, the development efforts saved by using a financial contract DSL implementation can greatly outweigh the efficiency gains. \\

We hope that these findings can be applied in the world of financial engineering, allowing financial institutions to implement financial smart contracts with significantly less effort than a bespoke approach on many fronts.


\section{Reflections}

When it comes to developing the smart contract which implements SmartFin, there are definitely different approaches that could have been taken. Some of the issues discussed regarding the implemented smart contract in chapter \ref{evaluation}, like the requirement of function arguments to be serialized and the inefficient usage of storage, came about mainly as a result of using Rust and the \texttt{pwasm} modules. There were also some other issues with this approach which impacted development, including difficulty with building the smart contract on different systems from the same repository, and difficulty debugging due to bugs in the \texttt{pwasm} modules' implementations. The \texttt{pwasm} modules are still in active development and have not yet had a 1.0 release, so some of this is to be expected.

While these issues are inconvenient to say the least, different approaches to implementation are not perfect either; implementing the SmartFin smart contract in Solidity, for instance, would require much more care to avoid vulnerabilities like integer overflow/underflow on arithmetic operations, and would require a more complicated development setup automated testing. As such, there is no perfect approach to implementing this smart contract, but it may have been beneficial to perform some hands-on evaluation of different approaches rather than relying mainly on research; this could have allowed a more ideal development process to have been used, resulting in a more ideal final product. \\

After developing in the blockchain ecosystem for several months, certain insights can be gained as to issues with the field and some of their potential solutions. It is clear that blockchain development is still cutting-edge, but not necessarily for all the right reasons. One of the aspects of blockchain development which caused a significant amount of friction during development is the ecosystem of tools and technologies; while there are many tools to be used, most are incomplete or in early development, and many tools tend to only be usable in very specific circumstances. The specificity of tools seems to be a result of the relatively fragmented nature of blockchain development as a field, where what works on Ethereum blockchains won't always work on Bitcoin or Ripple blockchains. Blockchain development tools would be much more useful if they could be used with different types of blockchains, which could be possible of blockchains followed some set of standards - similar to how browsers follow web standards devised by the W3C\cite{w3c-standards}.

Besides their specificity, tools for blockchain development also tend to have lacking, outdated, or extremely technical documentation -  where a user will struggle or be completely unable to understand how to use a given tool without prior knowledge. This may be partially be because blockchain as a platform is still in its relatively early days, but improved documentation would go a long way to opening up blockchain development to many more developers.


\section{Areas for Future Work}

While the essential functionality of SmartFin's smart contract implementation is implemented in this project, there are a number of areas that could be further developed. The findings in these areas could be useful both for users of SmartFin and for financial institutions as a whole.

\subsection{Maximal SmartFin Contract Evaluation and Numerical Modelling}

Currently the web client allows the user to perform step-by-step evaluation of a SmartFin contract definition, setting the times at which the contract and sub-contracts are acquired, and the branches taken for \texttt{or} combinator sub-contracts (see section \ref{client-evaluate} for more details). While this is useful for testing financial contracts, it would be even more useful to provide some maximal/minimal evaluation functionality. This could show the author of a financial contract how much the contract could possible gain or cost, highlighting any egregious errors which could lose one party a significant amount of funds. \\

The web client's evaluation framework (the \texttt{Evaluator} class described in section \ref{evaluator}) could be used for maximal and minimal evaluation with some extra implementation effort, but the biggest problem with this is the value of observables. How can an algorithm decide whether one observable's value is bigger than another, especially when these values may not be known in the real world yet? \\

To handle this issue, the web client could provide some numerical modelling functionality. The user could provide the details required to form a numerical model of the value of each observable over time, and the web client could base comparisons between observables on the average expected value of the observables in the given time period. \\

There are several methods of implementing this numerical modelling. One option would be a lattice-based model, which uses a binomial tree to represent the probabilistic values a measurement can take over time\cite{lattice-model}. In the paper by Peyton Jones et al.\cite{SPJ} where the original combinator DSL is defined, lattice-based modelling is used to evaluate the financial contract definition with regards to all probabilistic influences, including interest rates, exchange rates, and the value of observables; as such, a similar implementation of this is shown to be possible (albeit very complicated).


\subsection{Expansion of the SmartFin DSL}

While the SmartFin DSL does allow users to represent a large portion of financial contracts, not \textit{every} financial contract can be represented this way\cite{SPJ}. For a financial institution, the benefits to using the SmartFin DSL to compose financial contracts will always apply, but financial contracts which must instead be represented by complicated prose with a bespoke Solidity smart contract implementation will not stand to gain from this work. These bespoke smart contracts must be tested and analysed individually to prevent easy-to-miss errors from effecting the contract's behaviour, and their implementation can require hundreds of lines in comparison to tens of combinators. \\

Expanding the SmartFin DSL and its smart contract implementation serves to reduce the number of bespoke financial smart contracts and verbose traditional financial contracts that need to be implemented. In doing this, financial institutions can leverage SmartFin to produce financial contracts with less development effort, or can learn from the combinators employed to design their own DSL for a similar purpose. \\

In terms of the directions in which SmartFin should be expanded, it is quite difficult to design new combinators. After a discussion with Dr. Panos Parpas of Imperial College London, a former professional financial contract author, one area of financial contracts which was notably absent from the original DSL presented by Peyton Jones et al.\cite{SPJ} is comparison; there are no combinators in the DSL which specifically handle comparisons between values. While this could be encoded in the definition of an observable, this usage of observables retreats back into the world of verbose and complex financial contracts, making evaluation and smart contract representation more difficult. As such, specific encoding of comparison operators in SmartFin would maintain the elegance of SmartFin financial contracts while expanding upon functionality.